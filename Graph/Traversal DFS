# there is very minimum difference in bfs and dfs traversal we can also use list instead of deque in this dfs but the pop operation will take only 1 operation so we are using this
# deque in place of list the every logic is same as bfs
from collections import deque
# this code will work for both directed and undirected graph
def dfs(adj):
    vis = set()
    n = len(adj)
    for i in range(n):                # loop ensures disconnected components are also covered
        if i in vis:
            continue
		vis.add(i)
        st = deque([i])
        while st:
            el = st.pop()              # take element from queue
            print(el, end=' ')
            for adjel in range(n):    # check all neighbors
                if adj[el][adjel] and adjel not in vis:
                    vis.add(adjel)    # mark visited
                    st.append(adjel)
        print()
